{"pages":[{"title":"About","text":"Hi! Welcome to Not Overflow. Our purpose is to help you prepare technical interviews in a more effective way. We are all aware of the existence of many good online coding pratice platforms such as Leetcode, GeeksforGeeks, HackeRrank and etc. But the problem is that they usually contain massive exercises and it’s (almost) impossible and not necessary to solve every single problem. In Not Overflow, we love discovering patterns. We will tell you how to come up with solutions for 10 problems on Leetcode in 20 minutes (This doesn’t include coding time since it differs from person to person) by finding patterns and understanding the core knowledge. We will also provide information on system design interview preparation and some techniques to be more productive during the preparation. This is important since we all have limited time! If you have any question/feedback or would like to join in our team, please drop an email to hi.notoverflow@gmail.com. SMART work pays off!","link":"/about/index.html"}],"posts":[{"title":"Not Overflow - SMART work pays off","text":"In Not Overflow, we love discovering patterns. We will tell you how to come up with solutions for 10 problems on Leetcode in 20 minutes (This doesn’t include coding time since it differs from person to person) by finding patterns and understanding the core knowledge. We will also provide information on system design interview preparation and some techniques to be more productive during the preparation. This is important since we all have limited time! Check out Archives to see all the articles. If you have any question/feedback or would like to join in our team, please drop an email to hi.notoverflow@gmail.com.","link":"/intro.html"},{"title":"The most popular coding interview question on Leetcode - TwoSum probelm and MORE II","text":"IntroductionTwoSum problem is one of the most frequently asked question in big Tech company interviews. In the previous article, we have explained some Leetcode problems that are very similar to TwoSum problem. In this article, we will explain the rest of the problems in the “family tree”. Let’s see what patterns we can find here. Leetcode problems that will be discussed in this article: 16. 3Sum Closest (Medium) 259. 3Sum Smaller (Medium) 454. 4Sum II (Medium) 523. Continuous Subarray Sum (Medium) 611. Valid Triangle Number (Medium) 713. Subarray Product Less Than K (Medium) 724. Find Pivot Index (Easy) 974. Subarray Sums Divisible by K (Medium) Subarray Sum problems Hint: Using cumulative sum/product together with pre-stored values (e.g. hashmap, sum) is a good option to solve subarry related problems. Time complexity is O(n). 974. Subarray Sums Divisible by K DescriptionGiven an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K. Example 1234Input: A = [4,5,0,-2,-3,1], K = 5Output: 7Explanation: There are 7 subarrays with a sum divisible by K = 5:[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] SolutionThis problem requires us to find sum that is divisible by K. The hashmap stores (sum + A[i]) % K instead of sum + A[i]. 12345678910111213def subarraysDivByK(sel, A, K): sum = 0 res = 0 hashmap = {} hashmap[0] = 1 for i in range(len(A)): sum = (sum + A[i])%K if sum in hashmap: res += hashmap[sum] hashmap[sum] += 1 else: hashmap[sum] = 1 return res 523. Continuous Subarray Sum DescriptionGiven a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer. Example 1234567Input: [23, 2, 4, 6, 7], k=6Output: TrueExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.Input: [23, 2, 6, 4, 7], k=6Output: TrueExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. SolutionThis problem is very similar to 974. The only difference is that we need to consider k=0 scenario and the size of the subarry has to be at least 2. So in the hashmap, the value should be the index instead of the frequency. 123456789101112131415def checkSubarraySum(self, nums, k): sum = 0 hashmap = {} hashmap[0] = -1 for i in range(0, len(nums)): sum += nums[i] if k!=0: sum = sum % k if sum in hashmap: if i - hashmap[sum] &gt; 1: return True else: hashmap[sum] = i return False 713. Subarray Product Less Than K DescriptionYour are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1234Input: nums = [10, 5, 2, 6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. SolutionIn this problem, we are dealing with product. The tricky part is that when we get a cummulative product which is larger than k, the product should divide the most left number till the product is smaller than k. Let’s look at the code: 1234567891011121314def numSubarrayProductLessThanK(self, nums, k): if k &lt;= 1: return 0 prd = 1 res = 0 left = 0 for i in range(len(nums)): prd *= nums[i] while prd &gt;= k: prd /= nums[left] # divide the most left number till it is smaller than k left += 1 res += i - left + 1 return res 724. Find Pivot Index (Easy) DescriptionGiven an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 123456789101112Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs.Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement. Solution In this case, we pre-store the sum of the list as summ. Every time we get new cummulative sum, we subtract the cummulative sum from summ and check if the result (which is the sum of numbers to the right of current index) is equal to the left part. 12345678def pivotIndex(self, nums): summ = sum(nums) left = 0 for idx, val in enumerate(nums): if left == summ - val - left: # right = summ - val - left return idx left += val return -1 3Sum Hint: When it comes to finding triplets which sums are smaller/larger/closest to the target, two-pointer is often a good solution. 259. 3Sum Smaller DescriptionGiven an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target. Example 12345Input: nums = [-2,0,1,3], and target = 2Output: 2 Explanation: Because there are two triplets which sums are less than 2: [-2,0,1] [-2,0,3] SolutionWhat it differs from 3Sum problem is that this one aims to find triplets which sums are less than K instead of equal to K. Two-pointers solution can be used but without if nums[left] + nums[right] == target condition. Compare the solution with 3Sum problem solution. 123456789101112131415161718192021def twoSumSmaller(self, nums, target): res = 0 left = 0 right = len(nums)-1 while left &lt; right: if nums[left] + nums[right] &lt; target: res += right - left left += 1 else: right -= 1 return res def threeSumSmaller(self, nums, target): if len(nums)&lt;3: return 0 nums = sorted(nums) res = 0 for i in range(0, len(nums)-2): res += self.twoSumSmaller(nums[i+1:len(nums)], target-nums[i]) return res 16. 3Sum Closest DescriptionGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example 12Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). SolutionAgain, two-pointer is a good solution here! But don’t forget to track the current distance abs(s - target) with the smallest distance so far. If the sum is equal to target, we can directly break and return the target. 1234567891011121314151617def threeSumClosest(self, nums, target): nums = sorted(nums) res = float(\"inf\") for i in range(len(nums)): left = i+1 right = len(nums)-1 while left &lt; right: s = nums[i] + nums[left] + nums[right] if abs(s - target) &lt; abs(res - target): # compare the current distance with the smallest distance so far res = s if s &lt; target: left += 1 elif s &gt; target: right -= 1 else: return res return res 611. Valid Triangle Number DescriptionGiven an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1234567Input: [2,2,3,4]Output: 3Explanation:Valid combinations are: 2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3 SolutionWe should first understand how to indentify if three numbers can form a triangle. Let’s say we have three numbers a, b and c. The rule is that when a &lt;= b &lt;= c, if a + b &gt; c, we can say a,b,c are valid triangle numbers. We use i, left and right represent the indices of three numbers in a sorted list and nums[right] &lt;= nums[left] &lt;= nums[i]. Initially, i=0, left=i+1, right=len(nums)-1. If nums[right] + nums[left] &gt; nums[i], we can say there are right - left valid combination because nums[right] can be replaced with nums[right-1], nums[right-2] till nums[left+1]. For example, (9,8,2), (9,8,3) … (9,8,7) are all valid triangle numbers. Let’s checkout the code! 12345678910111213def triangleNumber(self, nums): nums = sorted(nums,reverse=True) res = 0 for i in range(0, len(nums)-2): left = i + 1 right = len(nums)-1 while left &lt; right: if nums[right] + nums[left] &gt; nums[i]: res += right - left left += 1 else: right -= 1 return res 4Sum454. 4Sum II DescriptionGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1. Example 12345678910111213Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 SolutionWhen we encounter 4Sum related problems, it’s a good idea to split it into two TwoSum problems. In this case, we first calculate the sum of each combination in list A and B, store the sum and its frequency in a hashmap. Then we calculate the sum of each combination in list C and D. If -(C[i]+D[j]) is in the hashmap, we increase the res by hashmap[-(C[i]+D[j])]. 1234567891011121314151617def fourSumCount(self, A, B, C, D): hashmap = {} res = 0 for i in range(len(A)): for j in range(len(B)): s = A[i] + B[j] if s in hashmap: hashmap[s] += 1 else: hashmap[s] = 1 for i in range(len(C)): for j in range(len(D)): s = C[i] + D[j] if -s in hashmap: res += hashmap[-s] return res If you like this article, please share it with your peers! Stay tuned on Not Overflow! If you have any comments or suggestions or if you need engineers for your project, please drop an email to hi.notoverflow@gmail.com, we can have a chat.","link":"/two-sum-ii.html"},{"title":"The most popular coding interview question on Leetcode - TwoSum probelm and MORE I","text":"IntroductionTwoSum problem is one of the most frequently asked question in big Tech company interviews. In this article and the next article, we will explain not only this single problem, but also 16 more problems from Leetcode which are basically the extension of TwoSum. The following graph is what we call the “family tree” of TwoSum problem. They are connected because they have Similar Questions relation on Leetcode. Leetcode problems that will be discussed today: 1. Two Sum (Easy) 15. 3Sum (Medium) 18. 4Sum (Medium) 167. Two Sum II - Input array is sorted (Easy) 170. Two Sum III - Data structure design (Easy) 560. Subarray Sum Equals K (Medium) 653. Two Sum IV - Input is a BST (Easy) 1099. Two Sum Less Than K (Easy) The rest will be explained in the next article. TwoSumLet’s first look at the description of TwoSum problem. Description:Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 12Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution I - brute force Easy solution! We basically need two loops. In the first loop, index i starts from 0 to the end of the array. In the second loop, index j starts from i+1 to the end of the array. As each input would have exactly one solution, whenever nums[i] + nums[j] == target, we can return i and j. The time complexity would be O(n^2). Code sample: 123456# brute forcedef twoSum(self, nums, target): for i in range(len(nums) - 1): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j] Solution II - using hashmap Now we want to improve the time complexity. Instead of having two loops, we can have one loop plus a hashmap. The hashmap stores each num’s index and its partner number. Partner number is defined as target - nums[i]. If the current num is the partner number of its previous visited num, we return two indices. Time complexity is O(n). Space complexity is also O(n). Code sample: 12345678# hashmapdef twoSum(self, nums, target): hashmap = {} for i in range(len(nums)): if nums[i] not in hashmap: hashmap[target - nums[i]] = i else: return [hashmap[nums[i]], i] Solution III - using two-pointers Using two-pointer is also a good option here. It’s a bit like binary search. We first sort the nums together with their indices as we need to return the indices not the actual numbers. Then we define two pointers left and right . left starts from the beginning and right starts from the end. In the while loop, we calculate the sum of nums[left] and nums[right] . If the sum is bigger than the target, we do right-=1 . If the sum is smaller than the target, we do left+=1 . If the sum is equal to the target, we return two indices. Code sample: 123456789101112# two pointersdef twoSum(self, nums, target): nums = enumerate(nums) nums = sorted(nums, key=lambda x:x[1]) l, r = 0, len(nums)-1 while l &lt; r: if nums[l][1]+nums[r][1] == target: return sorted([nums[l][0], nums[r][0]]) elif nums[l][1]+nums[r][1] &lt; target: l += 1 else: r -= 1 ThreeSum &amp; FourSumTwoSum problem solutions can solve ThreeSum Problem and FourSum Problem as well. We only show the solution for FourSum as it’s already covered ThreeSum. Description:Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. The solution set must not contain duplicate triplets. Example: 12Given array nums = [-1, 0, 1, 2, -1, -4], and target = 0.A solution set is: [[-1, 0, 1],[-1, -1, 2]] The brute force solution is basically adding more loops and the time complexity is O(n^4). Here, we only show the code of using two-pointer. This problem might have multiple answers and the answer set must not contain duplicate triplets. So, we must skip numbers which are the same as their neighbours. The diagram below shows how it works inside twoSum function. The target is dynamic based on nums[i] in threeSum method. Let’s checkout the code! 123456789101112131415161718192021222324252627282930313233343536373839404142434445def twoSum(self, nums, target): nums = sorted(nums) l = 0 r = len(nums) - 1 res = [] while l &lt; r: tmp = nums[l] + nums[r] if tmp == target: res.append([nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: # skip duplicate numbers l += 1 while l &lt; r and nums[r] == nums[r + 1]: # skip duplicate numbers r -= 1 elif tmp &gt; target: r -= 1 else: l += 1 return res# O(n^2)def threeSum(self, nums, target): res = [] if len(nums) &lt; 3: return res for i in range(len(nums) - 2): if i &gt; 0 and nums[i] == nums[i - 1]: continue two_sum = self.twoSum(nums[i + 1 : len(nums)], target-nums[i]) for r in two_sum: res.append([nums[i]] + r) return res# O(n^3)def fourSum(self, nums, target): res = [] nums = sorted(nums) for i in range(len(nums)-3): if i &gt; 0 and nums[i] == nums[i-1]: # skip duplicate numbers continue three_sum = self.threeSum(nums[i+1:len(nums)], target-nums[i]) for r in three_sum: res.append([nums[i]] + r) return res TwoSum II &amp; TwoSum IIITwoSum II assumes that the list is already sorted. We can just go for the two-pointer solution. 123456789101112def twoSum(self, numbers, target): nums = numbers l = 0 r = len(nums) - 1 while l &lt; r: tmp = nums[l] + nums[r] if tmp == target: return [l+1, r+1] elif tmp &gt; target: r -= 1 else: l += 1 TwoSum III requires to design a class which includes add and find function. add - add the number to an internal data structure. find - find if there exists any pair of numbers which sum is equal to the value. 1234567891011121314151617class TwoSum(object): def __init__(self): self.hashmap = {} def add(self, number): if number in self.hashmap: self.hashmap[number] += 1 else: self.hashmap[number] = 1 def find(self, value): for key, val in self.hashmap.items(): if value - key in self.hashmap: # check if the \"partner\" is already in the hashmap if value - key != key or self.hashmap[key] &gt; 1: # avoid value=4, nums=[2] return True return False Two Sum IV puts numbers in a Binary Search Tree (BST). An important characteristic of BST is that if we do inorder traversal, we will get a sorted list. Two-pointer is a good option here. 12345678910111213141516171819202122class Solution(object): def inorder(self, root, res): if root: self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res) def findTarget(self, root, k): res = [] self.inorder(root, res) l = 0 r = len(res) - 1 while l &lt; r: sum = res[l] + res[r] if sum == k: return True elif sum &gt; k: r -= 1 else: l += 1 return False Subarray Sum Equals K &amp; TwoSum Less Than KSubarray Sum Equals K has an arry of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example: 12Input:nums = [1,1,1], k = 2Output: 2 Brute force solution considers every possible subarry of the given array. Whenenver the sum equals k, we can increment the result by 1. Time complexity would be O(n^3). Another solution is to use cumulative sum. We first get a cumulative sum array summ. The sum between index i and j in nums is calculated by doing summ[j] - summ[i]. Time complexity would be O(n^2). 1234567891011def subarraySum(self, nums, k): sum = [None for _ in nums] sum.insert(0,0) res = 0 for i in range(1, len(nums) + 1): sum[i] = sum[i - 1] + nums[i - 1] for i in range(len(nums)): for j in range(i + 1, len(nums) + 1): if sum[j] - sum[i] == k: res += 1 return res Another better solution posted on Leetcode is using hashmap. The idea is that when we accumulate the sum, we also check if it’s partner is already in the hashmap (the same concept of TwoSum but in a different scenario). 1234567891011121314def subarraySum(self, nums, k): sum = 0 res = 0 hashmap = {} hashmap[0] = 1 # include scenario like nums=[2] k=2 for i in range(len(nums)): sum += nums[i] if sum - k in hashmap: res += hashmap[sum-k] if sum in hashmap: hashmap[sum] += 1 else: hashmap[sum] = 1 return res Two Sum Less Than K gives an array A of integers and integer K, return the maximum S such that there exists i &lt; j with A[i] + A[j] = S and S &lt; K. If no i, j exist satisfying this equation, return -1. Example: 123456789Input: A = [34,23,1,24,75,33,54,8], K = 60Output: 58Explanation: We can use 34 and 24 to sum 58 which is less than 60.Input: A = [10,20,30], K = 15Output: -1Explanation: In this case it&apos;s not possible to get a pair sum less that 15. It’s an easy variant of TwoSum. We need to find numbers that sum up to a value less than K. Here is the coding using two-pointer solution. 12345678910111213def twoSumLessThanK(self, A, K): l = 0 r = len(A) - 1 A = sorted(A) res = -float(\"inf\") while l &lt; r: sum = A[l] + A[r] if sum == K or sum &gt; K: r -= 1 else: res = max(res, sum) l += 1 return res if res!=-float(\"inf\") else -1 If you like this article, please share it with your peers! Stay tuned on Not Overflow! If you have any comments or suggestions or if you need engineers for your project, please drop an email to hi.notoverflow@gmail.com, we can have a chat.","link":"/two-sum-I.html"},{"title":"Cracking 25 Tree problems on Leetcode in 1 hour I","text":"Leetcode problems that will be discussed today: 94. Binary Tree Inorder Traversal(Medium) 98. Validate Binary Search Tree(Medium) 144. Binary Tree Preorder Traversal(Medium) 230. Kth Smallest Element in a BST(Medium) 783. Minimum Distance Between BST Nodes","link":"/tree-i.html"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"two-pointer","slug":"two-pointer","link":"/tags/two-pointer/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"hashtable","slug":"hashtable","link":"/tags/hashtable/"},{"name":"tree","slug":"tree","link":"/tags/tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"}]}