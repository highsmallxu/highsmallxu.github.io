{"pages":[],"posts":[{"title":"Study note - Designing Data-Intensive Applications Chaprter I","text":"This is the first study note of book Designing Data-Intensive Applications. This book is recommended to anyone who develop applications that need some kind of backend for storing or processing data via network. It disusses different design principles of data systems and trade-offs, and various technologies that make the design happen. Chapter 1 Reliable, Scalable, and Maintainable ApplicationsA data-intensive application usually has common functionality: Store data persistently and the data is available to the other applications (database) Keep the results of expensive operations in memory to speed up reads (cache) Allow users to do quick search (search indexes) Process data in real-time, and handle data asynchronously (streaming process) Periodically process a large chunk of data (batch processing) Nowadays, applications have such demanding requirements that a single tool can’t meet all of the data processing and storing needs. So a real data system typically consists of various components. The book shows an example: During the design phase, there are a lot of tricky questions coming up: How do you ensure that the data remains correct and complete, even when things go wrong internally? How do you provide consistently good performance to clients, even when parts of your system are degraded? How do you scale to handle an increase in load? In general, these questions are closely connected to three core concepts of a data-intensive application, which are: Reliability Scalability Maintainability ReliabilityA reliable system should continue to work correctly even there are hardware, software and human errors. To what extend do we mean by “work correctly”? There are some typical expectations: The application performs the function that the user expects. The application tolerates user mistakes and unexpected behaviors. Its performance is good enough for basic requirements under expected load and data volume. It prevents unauthorized access and abuse. The book talks about an interesting point which is Fault vs Failure. A fault is usually defined as one component deviates from its specification, whereas a failure is when the system as a whole stops providing the required service to users. It is nearly impossible to reduce the chance of having a fault to zero, but what we can do is to Design a fault-tolerance system that prevents faults from causing failures. Hardware FaultsHardware faults include disk crash, the power grid has a blackout, network cable is unplugged. Anf hard disks are reporting as having a mean time to failure of about 10 to 50 years. Solutions Add redundancy to each hardware component to reduce failure rate of the system. Disks can be setup in RAID (Redundant Array of Inexpensive Disks) configurations. Servers have dual power supplies and hot-swappable CPUs. Datacenters have their own backup. The idea is that the redundant component can replace the broken component to keep a machine running. Using software fault-tolerance techniques. A system that can tolerate machine failure can be patched one node at a time without downtime of the entire system. Software FaultsSoftware faults include software bugs, a runaway process that uses up some shared resources, a service that the system requires goes down. Software errors are harder to anticipate and tend to cause many more system failures. Solutions Carefully thinking about assumptions and interactions in the system. Have thorough testing. Have isolated processed. Allow processes to crash and restart automatically. Measure, monitor and analyze system behavior in production. Human errorsHuman errors include configuration errors, etc. Solutions Design systems in a way that minimizes opportunities for error such as well-designed APIs. Decouple the places where people make the most mistakes from the places where they can cause failure. Provide fully featured non-production sandbox environments to let people try out. Test thoroughly, from unit tests to whole-system integration tests. Allow quick recovery from human errors. For example, make it fast to roll back configuration changes and code. Set up monitoring and send an alert when the chance of having a failure is high. ScalabilityA scalable system should be able to handle the increase in data volume, traffic volume or complexity. Describe loadLoad can be described with load parameters, such as Requests per second to a web server The ratio of reads or writes in a database The number of simultaneously active users The hit rate on a cache MaintainabilityA maintainable system should be easy for engineers and operators to continuously work on it.","link":"/intro.html"}],"tags":[],"categories":[{"name":"Study Note","slug":"Study-Note","link":"/categories/Study-Note/"}]}