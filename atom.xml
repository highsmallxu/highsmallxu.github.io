<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Not Overflow</title>
  
  <subtitle>Leetcode Solutions, Data Structure, Productivity</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://highsmallxu.github.io/"/>
  <updated>2019-10-06T14:10:46.306Z</updated>
  <id>https://highsmallxu.github.io/</id>
  
  <author>
    <name>Xiaoxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TwoSum problem and it&#39;s big family (part II)</title>
    <link href="https://highsmallxu.github.io/2019/10/05/two-sum-ii/"/>
    <id>https://highsmallxu.github.io/2019/10/05/two-sum-ii/</id>
    <published>2019-10-04T22:00:00.000Z</published>
    <updated>2019-10-06T14:10:46.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the previous article, I explained some Leetcode problems that have direct relations with TwoSum problem. In this article, I will explain the rest of the family. Let’s see what patterns we can find here. </p><img src="/images/two_sum_family_watermark.png" style="float: right;" width="400" height="400"><p>Leetcode problems that will be discussed in this article:</p><ul><li><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 3Sum Closest (Medium)</a></li><li><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 3Sum Smaller (Medium)</a></li><li><a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 4Sum II (Medium)</a></li><li><a href="https://leetcode.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. Continuous Subarray Sum (Medium)</a></li><li><a href="https://leetcode.com/problems/valid-triangle-number/" target="_blank" rel="noopener">611. Valid Triangle Number (Medium)</a></li><li><a href="https://leetcode.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. Subarray Product Less Than K (Medium)</a></li><li><a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. Find Pivot Index (Easy)</a></li><li><a href="https://leetcode.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. Subarray Sums Divisible by K (Medium)</a></li></ul><h2 id="Subarray-Sum-problems"><a href="#Subarray-Sum-problems" class="headerlink" title="Subarray Sum problems"></a>Subarray Sum problems</h2><blockquote><p>Using cumulative sum/product together with pre-stored values (e.g. hashmap, sum) is a good option to solve subarry related problems. Time complexity is O(n).</p></blockquote><p><a href="https://leetcode.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. Subarray Sums Divisible by K</a></p><p><strong>Description</strong><br>Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,5,0,-2,-3,1], K = 5</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: There are 7 subarrays with a sum divisible by K = 5:</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>This problem requires us to find sum that is divisible by K. The hashmap stores <code>(sum + A[i]) % K</code> instead of <code>sum + A[i]</code>.</p><img src="/images/1_4.png" style="float: right;" width="200" height="200"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraysDivByK</span><span class="params">(sel, A, K)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    hashmap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        sum = (sum + A[i])%K</span><br><span class="line">        <span class="keyword">if</span> sum <span class="keyword">in</span> hashmap:</span><br><span class="line">            res += hashmap[sum]</span><br><span class="line">            hashmap[sum] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashmap[sum] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. Continuous Subarray Sum</a></p><p><strong>Description</strong><br>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [23, 2, 4, 6, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br><span class="line"></span><br><span class="line">Input: [23, 2, 6, 4, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>This problem is very similar to 974. The only difference is that we need to consider k=0 scenario and the size of the subarry has to be at least 2. So in the hashmap, the value should be the index instead of the frequency. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    hashmap[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)):</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> k!=<span class="number">0</span>:</span><br><span class="line">            sum = sum % k</span><br><span class="line">        <span class="keyword">if</span> sum <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">if</span> i - hashmap[sum] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashmap[sum] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. Subarray Product Less Than K</a></p><p><strong>Description</strong><br>Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [10, 5, 2, 6], k = 100</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</span><br><span class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>In this problem, we are dealing with product. The tricky part is that when we get a cummulative product which is larger than k, the product should divide the most left number till the product is smaller than k. </p><img src="/images/1_5.png"><p>Let’s look at the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    prd = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        prd *= nums[i]</span><br><span class="line">        <span class="keyword">while</span> prd &gt;= k:</span><br><span class="line">            prd /= nums[left] <span class="comment"># divide the most left number till it is smaller than k</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        res += i - left + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. Find Pivot Index (Easy)</a></p><p><strong>Description</strong><br>Given an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.</span><br><span class="line">Also, 3 is the first index where this occurs.</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">There is no index that satisfies the conditions in the problem statement.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>In this case, we pre-store the sum of the list as <code>summ</code>. Every time we get new cummulative sum, we subtract the cummulative sum from <code>summ</code> and check if the result (which is the sum of numbers to the right of current index) is equal to the left part. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    summ = sum(nums)</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> left == summ - val - left: <span class="comment"># right = summ - val - left </span></span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">        left += val</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><blockquote><p>When it comes to finding triplets which sums are smaller/larger/closest to the target, two-pointer is often a good solution. </p></blockquote><p><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 3Sum Smaller</a></p><p><strong>Description</strong><br>Given an array of n integers <code>nums</code> and a <code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>. </p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,0,1,3], and target = 2</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: Because there are two triplets which sums are less than 2:</span><br><span class="line">             [-2,0,1]</span><br><span class="line">             [-2,0,3]</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>What it differs from 3Sum problem is that this one aims to find triplets which sums are less than K instead of equal to K. Two-pointers solution can be used but without <code>if nums[left] + nums[right] == target</code> condition. Compare the solution with <a href="/2019/10/01/two-sum-I/#ThreeSum-amp-FourSum">3Sum problem solution</a>. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSumSmaller</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> nums[left] + nums[right] &lt; target:</span><br><span class="line">            res += right - left</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumSmaller</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    nums = sorted(nums)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)<span class="number">-2</span>):</span><br><span class="line">        res += self.twoSumSmaller(nums[i+<span class="number">1</span>:len(nums)], target-nums[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 3Sum Closest</a></p><p><strong>Description</strong><br>Given an array <code>nums</code> of n integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>Again, two-pointer is a good solution here! But don’t forget to track the current distance <code>abs(s - target)</code> with the smallest distance so far. If the sum is equal to <code>target</code>, we can directly break and return the <code>target</code>. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    nums = sorted(nums)</span><br><span class="line">    res = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        left = i+<span class="number">1</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> abs(s - target) &lt; abs(res - target): <span class="comment"># compare the current distance with the smallest distance so far </span></span><br><span class="line">                res = s</span><br><span class="line">            <span class="keyword">if</span> s &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s &gt; target:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/valid-triangle-number/" target="_blank" rel="noopener">611. Valid Triangle Number</a></p><p><strong>Description</strong><br>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Valid combinations are: </span><br><span class="line">2,3,4 (using the first 2)</span><br><span class="line">2,3,4 (using the second 2)</span><br><span class="line">2,2,3</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>We should first understand how to indentify if three numbers can form a triangle. Let’s say we have three numbers <code>a</code>, <code>b</code> and <code>c</code>. The rule is that when <code>a &lt;= b &lt;= c</code>, if <code>a + b &gt; c</code>, we can say <code>a</code>,<code>b</code>,<code>c</code> are valid triangle numbers. </p><p>We use <code>i</code>, <code>left</code> and <code>right</code> represent the indices of three numbers in a sorted list and <code>nums[right] &lt;= nums[left] &lt;= nums[i]</code>. Initially, <code>i=0</code>, <code>left=i+1</code>, <code>right=len(nums)-1</code>. </p><p>If <code>nums[right] + nums[left] &gt; nums[i]</code>, we can say there are <code>right - left</code> valid combination because <code>nums[right]</code> can be replaced with <code>nums[right-1]</code>, <code>nums[right-2]</code> till <code>nums[left+1]</code>. For example, (9,8,2), (9,8,3) … (9,8,7) are all valid triangle numbers. </p><img src="/images/1_6.png"><p>Let’s checkout the code! </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    nums = sorted(nums,reverse=<span class="literal">True</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)<span class="number">-2</span>):</span><br><span class="line">        left = i + <span class="number">1</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> nums[right] + nums[left] &gt; nums[i]:</span><br><span class="line">                res += right - left</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h2><p><a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 4Sum II</a></p><p><strong>Description</strong><br>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.<br>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1. </p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>When we encounter 4Sum related problems, it’s a good idea to split it into two TwoSum problems. In this case, we first calculate the sum of each combination in list <code>A</code> and <code>B</code>, store the sum and its frequency in a hashmap. Then we calculate the sum of each combination in list <code>C</code> and <code>D</code>. If <code>-(C[i]+D[j])</code> is in the hashmap, we increase the <code>res</code> by <code>hashmap[-(C[i]+D[j])]</code>. </p><img src="/images/1_7.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span><span class="params">(self, A, B, C, D)</span>:</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B)):</span><br><span class="line">            s = A[i] + B[j]</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[s] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[s] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(C)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(D)):</span><br><span class="line">            s = C[i] + D[j]</span><br><span class="line">            <span class="keyword">if</span> -s <span class="keyword">in</span> hashmap:</span><br><span class="line">                res += hashmap[-s]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>If you like this blog, please share it with your peers! Stay tuned on NotOverflow!</strong></p><p><strong>If you have any comments or suggestions or if you need engineers for your project, please drop an email to <a href="mailto:hi.notoverflow@gmail.com" target="_blank" rel="noopener">hi.notoverflow@gmail.com</a>, we can have a chat.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;In the previous article, I exp
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://highsmallxu.github.io/tags/leetcode/"/>
    
      <category term="data structure" scheme="https://highsmallxu.github.io/tags/data-structure/"/>
    
      <category term="two-pointer" scheme="https://highsmallxu.github.io/tags/two-pointer/"/>
    
      <category term="array" scheme="https://highsmallxu.github.io/tags/array/"/>
    
      <category term="hashtable" scheme="https://highsmallxu.github.io/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>TwoSum problem and it&#39;s big family (part I)</title>
    <link href="https://highsmallxu.github.io/2019/10/01/two-sum-I/"/>
    <id>https://highsmallxu.github.io/2019/10/01/two-sum-I/</id>
    <published>2019-09-30T22:00:00.000Z</published>
    <updated>2019-10-06T13:53:54.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">TwoSum problem</a> is one of the most classic problems on Leetcode. You can find many blogs online explaining this problem. But in this blog (and the next blog), I will focus on not only solving this single problem, but also it’s “family members” surrounding it. </p><p>The following graph is the “family tree” of TwoSum problem. They are connected because they have <strong>Similar Questions</strong> relation on Leetcode. In this blog, I’m going to explain the problems which have close relations to TwoSum problem.  The rest will be explained in the next blog.</p><img src="/images/two_sum_family_watermark.png" style="float: right;" width="400" height="400"><p>Leetcode problems that will be discussed today:</p><ul><li><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum (Easy)</a></li><li><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">15. 3Sum (Medium)</a></li><li><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">18. 4Sum (Medium)</a></li><li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted (Easy)</a></li><li><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">170. Two Sum III - Data structure design (Easy)</a></li><li><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. Subarray Sum Equals K (Medium)</a></li><li><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST (Easy)</a></li><li><a href="https://leetcode.com/problems/two-sum-less-than-k/" target="_blank" rel="noopener">1099. Two Sum Less Than K (Easy)</a></li></ul><h2 id="TwoSum"><a href="#TwoSum" class="headerlink" title="TwoSum"></a>TwoSum</h2><p>Let’s first look at the description of TwoSum problem.</p><p><strong>Description:</strong><br>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <strong>same</strong> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Solution I - Brute force</strong></p><p>For the brute force solution, we need two levels of loop. In the first level, index <code>i</code> starts from 0 to the end of the array. In the second level, index <code>j</code> starts from <code>i+1</code> to the end of the array. As each input would have exactly one solution, whenever <code>nums[i] + nums[j] == target</code>, we can return <code>i</code> and <code>j</code>. The time complexity would be O(n^2). </p><p>Here is the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># brute force</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure><p><strong>Solution II - using hashmap</strong></p><p>The next step is to improve the brute force solution in terms of time complexity. Instead of having two loops, we can have one loop plus a hashmap. The hashmap stores each num’s index and its partner number. Partner number is defined as <code>target - nums[i]</code>. If the current num is the partner number of its previous visited num, we return two indices. Time complexity is O(n). Space complexity is also O(n). </p><p>Here is the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[target - nums[i]] = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [hashmap[nums[i]], i]</span><br></pre></td></tr></table></figure><p><strong>Solution III - using two-pointers</strong></p><p>Two-pointer solution is also a good option here. It’s a bit like binary search. We first sort the nums together with their indices as we need to return the indices not the actual numbers. Then we define two pointers <code>left</code> and <code>right</code> . <code>left</code> starts from the beginning and <code>right</code> starts from the end. In the while loop, we calculate the sum of <code>nums[left]</code> and <code>nums[right]</code> . If the sum is bigger than the target, we do <code>right-=1</code> . If the sum is smaller than the target, we do <code>left+=1</code> . If the sum is equal to the target, we return two indices.</p><p>Here is the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># two pointers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">nums = enumerate(nums)</span><br><span class="line">    nums = sorted(nums, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">    l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">if</span> nums[l][<span class="number">1</span>]+nums[r][<span class="number">1</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> sorted([nums[l][<span class="number">0</span>], nums[r][<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">elif</span> nums[l][<span class="number">1</span>]+nums[r][<span class="number">1</span>] &lt; target:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="ThreeSum-amp-FourSum"><a href="#ThreeSum-amp-FourSum" class="headerlink" title="ThreeSum &amp; FourSum"></a>ThreeSum &amp; FourSum</h2><p>TwoSum problem solutions can be easily extended to solve <a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">ThreeSum Problem</a> and <a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">FourSum Problem</a>. I’m only showing the solution for FourSum as it’s already covered ThreeSum.</p><p><strong>Description:</strong><br>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4], and target = 0.</span><br><span class="line">A solution set is: [[-1, 0, 1],[-1, -1, 2]]</span><br></pre></td></tr></table></figure><p>The brute force solution is basically adding more loops and the time complexity is O(n^4). Here, I’m only showing the code of two-pointer solution. </p><p>This problem might have multiple solutions and the solution set must not contain duplicate triplets. So, we must skip numbers which are the same as their neighbours. The diagram below shows how it works inside <code>twoSum</code> function. The <code>target</code> is dynamic based on <code>nums[i]</code> in <code>threeSum</code> method.</p><img src="/images/1_1.png" width="200" height="200"><img src="/images/1_2.png" width="200" height="200"><p>Let’s checkout the code!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    nums = sorted(nums)</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(nums) - <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        tmp = nums[l] + nums[r]</span><br><span class="line">        <span class="keyword">if</span> tmp == target:</span><br><span class="line">            res.append([nums[l], nums[r]])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]: <span class="comment"># skip duplicate numbers</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: <span class="comment"># skip duplicate numbers</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> tmp &gt; target:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        two_sum = self.twoSum(nums[i + <span class="number">1</span> : len(nums)], target-nums[i])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> two_sum:</span><br><span class="line">            res.append([nums[i]] + r)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n^3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    nums = sorted(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-3</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="comment"># skip duplicate numbers </span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        three_sum = self.threeSum(nums[i+<span class="number">1</span>:len(nums)], target-nums[i])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> three_sum:</span><br><span class="line">            res.append([nums[i]] + r)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="TwoSum-II-amp-TwoSum-III"><a href="#TwoSum-II-amp-TwoSum-III" class="headerlink" title="TwoSum II &amp; TwoSum III"></a>TwoSum II &amp; TwoSum III</h2><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">TwoSum II</a> assumes that the list is already sorted. We can just go for the two-pointer solution.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">    nums = numbers</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        tmp = nums[l] + nums[r]</span><br><span class="line">        <span class="keyword">if</span> tmp == target:</span><br><span class="line">            <span class="keyword">return</span> [l+<span class="number">1</span>, r+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> tmp &gt; target:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">TwoSum III</a> requires to design a class which includes <code>add</code> and <code>find</code> function. <code>add</code> - add the number to an internal data structure. <code>find</code> - find if there exists any pair of numbers which sum is equal to the value. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.hashmap = &#123;&#125;        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            self.hashmap[number] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.hashmap[number] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> self.hashmap.items():</span><br><span class="line">            <span class="keyword">if</span> value - key <span class="keyword">in</span> self.hashmap: <span class="comment"># check if the "partner" is already in the hashmap</span></span><br><span class="line">                <span class="keyword">if</span> value - key != key <span class="keyword">or</span> self.hashmap[key] &gt; <span class="number">1</span>: <span class="comment"># avoid value=4, nums=[2]</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">Two Sum IV</a> puts numbers in a Binary Search Tree (BST). An important characteristic of BST is that if we do inorder traversal, we will get a sorted list. Two-pointer is a good option here.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorder(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.inorder(root.right, res)      </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.inorder(root, res)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(res) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            sum = res[l] + res[r]</span><br><span class="line">            <span class="keyword">if</span> sum == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> sum &gt; k:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="Subarray-Sum-Equals-K-amp-TwoSum-Less-Than-K"><a href="#Subarray-Sum-Equals-K-amp-TwoSum-Less-Than-K" class="headerlink" title="Subarray Sum Equals K &amp; TwoSum Less Than K"></a>Subarray Sum Equals K &amp; TwoSum Less Than K</h2><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a> has an arry of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Brute force solution considers every possible subarry of the given array. Whenenver the sum equals k, we can increment the result by 1. Time complexity would be O(n^3). </p><p>Another solution is to use cumulative sum. We first get a cumulative sum array <code>summ</code>. The sum between index <code>i</code> and <code>j</code> in <code>nums</code> is calculated by doing <code>summ[j] - summ[i]</code>. Time complexity would be O(n^2). </p><img src="/images/1_3.png" width="120" height="120"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    sum = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> nums]</span><br><span class="line">    sum.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums) + <span class="number">1</span>):</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> sum[j] - sum[i] == k:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Another better solution posted on Leetcode is using hashmap. The idea is that when we accumulate the sum, we also check if it’s partner is already in the hashmap (the same concept of TwoSum but in a different scenario). </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    hashmap[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># include scenario like nums=[2] k=2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> sum - k <span class="keyword">in</span> hashmap:</span><br><span class="line">            res += hashmap[sum-k]</span><br><span class="line">        <span class="keyword">if</span> sum <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[sum] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashmap[sum] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/two-sum-less-than-k/" target="_blank" rel="noopener">Two Sum Less Than K</a> gives an array A of integers and integer K, return the maximum S such that there exists <code>i &lt; j</code> with <code>A[i] + A[j] = S</code> and <code>S &lt; K</code>. If no <code>i</code>, <code>j</code> exist satisfying this equation, return -1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [34,23,1,24,75,33,54,8], K = 60</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: </span><br><span class="line">We can use 34 and 24 to sum 58 which is less than 60.</span><br><span class="line"></span><br><span class="line">Input: A = [10,20,30], K = 15</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">In this case it&apos;s not possible to get a pair sum less that 15.</span><br></pre></td></tr></table></figure><p>It’s an easy variant of TwoSum. We need to find numbers that sum up to a value less than K. Here is the coding using two-pointer solution. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSumLessThanK</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(A) - <span class="number">1</span></span><br><span class="line">    A = sorted(A)</span><br><span class="line">    res = -float(<span class="string">"inf"</span>)    </span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        sum = A[l] + A[r]</span><br><span class="line">        <span class="keyword">if</span> sum == K <span class="keyword">or</span> sum &gt; K:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = max(res, sum)</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">if</span> res!=-float(<span class="string">"inf"</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>If you like this blog, please share it with your peers! Stay tuned on NotOverflow!</strong></p><p><strong>If you have any comments or suggestions or if you need engineers for your project, please drop an email to <a href="mailto:hi.notoverflow@gmail.com" target="_blank" rel="noopener">hi.notoverflow@gmail.com</a>, we can have a chat.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://highsmallxu.github.io/tags/leetcode/"/>
    
      <category term="data structure" scheme="https://highsmallxu.github.io/tags/data-structure/"/>
    
      <category term="two-pointer" scheme="https://highsmallxu.github.io/tags/two-pointer/"/>
    
      <category term="array" scheme="https://highsmallxu.github.io/tags/array/"/>
    
      <category term="hashtable" scheme="https://highsmallxu.github.io/tags/hashtable/"/>
    
  </entry>
  
</feed>
