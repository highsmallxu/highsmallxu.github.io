[{"title":"TwoSum problem and its similar Questions (part II)","url":"/two-sum-ii.html","content":"\n## Introduction\n\nIn the previous article, I explained some Leetcode problems that have direct relations with TwoSum problem. In this article, I will explain the rest of the family. Let's see what patterns we can find here. \n\n<img src=\"/images/two_sum_family_watermark.png\" style=\"float: right;\" width=\"400\" height=\"400\">\n\nLeetcode problems that will be discussed in this article:\n- [16. 3Sum Closest (Medium)](https://leetcode.com/problems/3sum-closest/)\n- [259. 3Sum Smaller (Medium)](https://leetcode.com/problems/3sum-smaller/)\n- [454. 4Sum II (Medium)](https://leetcode.com/problems/4sum-ii/)\n- [523. Continuous Subarray Sum (Medium)](https://leetcode.com/problems/continuous-subarray-sum/)\n- [611. Valid Triangle Number (Medium)](https://leetcode.com/problems/valid-triangle-number/)\n- [713. Subarray Product Less Than K (Medium)](https://leetcode.com/problems/subarray-product-less-than-k/)\n- [724. Find Pivot Index (Easy)](https://leetcode.com/problems/find-pivot-index/)\n- [974. Subarray Sums Divisible by K (Medium)](https://leetcode.com/problems/subarray-sums-divisible-by-k/)\n\n\n## Subarray Sum problems \n\n> Using cumulative sum/product together with pre-stored values (e.g. hashmap, sum) is a good option to solve subarry related problems. Time complexity is O(n).\n\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/)\n\n**Description**\nGiven an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.\n\n**Example**\n```\nInput: A = [4,5,0,-2,-3,1], K = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by K = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n```\n\n**Solution**\nThis problem requires us to find sum that is divisible by K. The hashmap stores `(sum + A[i]) % K` instead of `sum + A[i]`.\n\n<img src=\"/images/1_4.png\" style=\"float: right;\" width=\"200\" height=\"200\">\n\n\n```python\ndef subarraysDivByK(sel, A, K):\n    sum = 0\n    res = 0\n    hashmap = {}\n    hashmap[0] = 1\n    for i in range(len(A)):\n        sum = (sum + A[i])%K\n        if sum in hashmap:\n            res += hashmap[sum]\n            hashmap[sum] += 1\n        else:\n            hashmap[sum] = 1\n    return res\n```\n\n[523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)\n\n**Description**\nGiven a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.\n\n**Example**\n```\nInput: [23, 2, 4, 6, 7],  k=6\nOutput: True\nExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n\nInput: [23, 2, 6, 4, 7],  k=6\nOutput: True\nExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n```\n**Solution**\nThis problem is very similar to 974. The only difference is that we need to consider k=0 scenario and the size of the subarry has to be at least 2. So in the hashmap, the value should be the index instead of the frequency. \n\n\n```python\ndef checkSubarraySum(self, nums, k):\n    sum = 0\n    hashmap = {}\n    hashmap[0] = -1\n\n    for i in range(0, len(nums)):\n        sum += nums[i]\n        if k!=0:\n            sum = sum % k\n        if sum in hashmap:\n            if i - hashmap[sum] > 1:\n                return True\n        else:\n            hashmap[sum] = i\n    return False\n```\n\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)\n\n**Description**\nYour are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.\n\n**Example**\n```\nInput: nums = [10, 5, 2, 6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n```\n\n**Solution**\nIn this problem, we are dealing with product. The tricky part is that when we get a cummulative product which is larger than k, the product should divide the most left number till the product is smaller than k. \n\n<img src=\"/images/1_5.png\">\n\n\nLet's look at the code:\n\n```python\ndef numSubarrayProductLessThanK(self, nums, k):\n    if k <= 1:\n        return 0\n        \n    prd = 1\n    res = 0\n    left = 0\n    for i in range(len(nums)):\n        prd *= nums[i]\n        while prd >= k:\n            prd /= nums[left] # divide the most left number till it is smaller than k\n            left += 1\n        res += i - left + 1\n    return res\n```\n\n\n[724. Find Pivot Index (Easy)](https://leetcode.com/problems/find-pivot-index/)\n\n**Description**\nGiven an array of integers nums, write a method that returns the \"pivot\" index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n\n**Example**\n```\nInput: \nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation: \nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\nInput: \nnums = [1, 2, 3]\nOutput: -1\nExplanation: \nThere is no index that satisfies the conditions in the problem statement.\n```\n\n**Solution**\n\nIn this case, we pre-store the sum of the list as `summ`. Every time we get new cummulative sum, we subtract the cummulative sum from `summ` and check if the result (which is the sum of numbers to the right of current index) is equal to the left part. \n\n```python\ndef pivotIndex(self, nums):\n    summ = sum(nums)\n    left = 0\n    for idx, val in enumerate(nums):\n        if left == summ - val - left: # right = summ - val - left \n            return idx\n        left += val\n    return -1\n```\n\n## 3Sum \n\n> When it comes to finding triplets which sums are smaller/larger/closest to the target, two-pointer is often a good solution. \n\n[259. 3Sum Smaller](https://leetcode.com/problems/3sum-smaller/)\n\n**Description**\nGiven an array of n integers `nums` and a `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`. \n\n**Example**\n```\nInput: nums = [-2,0,1,3], and target = 2\nOutput: 2 \nExplanation: Because there are two triplets which sums are less than 2:\n             [-2,0,1]\n             [-2,0,3]\n```\n\n**Solution**\nWhat it differs from 3Sum problem is that this one aims to find triplets which sums are less than K instead of equal to K. Two-pointers solution can be used but without `if nums[left] + nums[right] == target` condition. Compare the solution with [3Sum problem solution](/2019/10/01/two-sum-I/#ThreeSum-amp-FourSum). \n\n```python\ndef twoSumSmaller(self, nums, target):\n    res = 0\n    left = 0\n    right = len(nums)-1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            res += right - left\n            left += 1\n        else:\n            right -= 1\n    return res\n        \ndef threeSumSmaller(self, nums, target):\n    if len(nums)<3:\n        return 0\n        \n    nums = sorted(nums)\n    res = 0\n    for i in range(0, len(nums)-2):\n        res += self.twoSumSmaller(nums[i+1:len(nums)], target-nums[i])\n    return res\n```\n\n[16. 3Sum Closest](https://leetcode.com/problems/3sum-closest/)\n\n**Description**\nGiven an array `nums` of n integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n**Example**\n```\nGiven array nums = [-1, 2, 1, -4], and target = 1.\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n```\n\n**Solution**\nAgain, two-pointer is a good solution here! But don't forget to track the current distance `abs(s - target)` with the smallest distance so far. If the sum is equal to `target`, we can directly break and return the `target`. \n\n\n```python\ndef threeSumClosest(self, nums, target):\n    nums = sorted(nums)\n    res = float(\"inf\")\n    for i in range(len(nums)):\n        left = i+1\n        right = len(nums)-1\n        while left < right:\n            s = nums[i] + nums[left] + nums[right]\n            if abs(s - target) < abs(res - target): # compare the current distance with the smallest distance so far \n                res = s\n            if s < target:\n                left += 1\n            elif s > target:\n                right -= 1\n            else:\n                return res\n    return res\n```\n\n[611. Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)\n\n**Description**\nGiven an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n\n**Example**\n```\nInput: [2,2,3,4]\nOutput: 3\nExplanation:\nValid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n```\n\n**Solution**\nWe should first understand how to indentify if three numbers can form a triangle. Let's say we have three numbers `a`, `b` and `c`. The rule is that when `a <= b <= c`, if `a + b > c`, we can say `a`,`b`,`c` are valid triangle numbers. \n\nWe use `i`, `left` and `right` represent the indices of three numbers in a sorted list and `nums[right] <= nums[left] <= nums[i]`. Initially, `i=0`, `left=i+1`, `right=len(nums)-1`. \n\nIf `nums[right] + nums[left] > nums[i]`, we can say there are `right - left` valid combination because `nums[right]` can be replaced with `nums[right-1]`, `nums[right-2]` till `nums[left+1]`. For example, (9,8,2), (9,8,3) ... (9,8,7) are all valid triangle numbers. \n\n<img src=\"/images/1_6.png\">\n\nLet's checkout the code! \n```python\ndef triangleNumber(self, nums):\n    nums = sorted(nums,reverse=True)\n    res = 0\n    for i in range(0, len(nums)-2):\n        left = i + 1\n        right = len(nums)-1\n        while left < right:\n            if nums[right] + nums[left] > nums[i]:\n                res += right - left\n                left += 1\n            else:\n                right -= 1\n    return res\n```\n\n\n## 4Sum\n\n[454. 4Sum II](https://leetcode.com/problems/4sum-ii/)\n\n**Description**\nGiven four lists A, B, C, D of integer values, compute how many tuples `(i, j, k, l)` there are such that `A[i] + B[j] + C[k] + D[l]` is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1. \n\n**Example**\n```\nInput:\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\nOutput:\n2\n\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n```\n\n\n**Solution**\nWhen we encounter 4Sum related problems, it's a good idea to split it into two TwoSum problems. In this case, we first calculate the sum of each combination in list `A` and `B`, store the sum and its frequency in a hashmap. Then we calculate the sum of each combination in list `C` and `D`. If `-(C[i]+D[j])` is in the hashmap, we increase the `res` by `hashmap[-(C[i]+D[j])]`. \n\n<img src=\"/images/1_7.png\">\n\n```python\ndef fourSumCount(self, A, B, C, D):\n    hashmap = {}\n    res = 0\n    for i in range(len(A)):\n        for j in range(len(B)):\n            s = A[i] + B[j]\n            if s in hashmap:\n                hashmap[s] += 1\n            else:\n                hashmap[s] = 1\n\n    for i in range(len(C)):\n        for j in range(len(D)):\n            s = C[i] + D[j]\n            if -s in hashmap:\n                res += hashmap[-s]\n    return res\n```\n\n**If you like this blog, please share it with your peers! Stay tuned on NotOverflow!**\n\n**If you have any comments or suggestions or if you need engineers for your project, please drop an email to hi.notoverflow@gmail.com, we can have a chat.**","tags":["leetcode","data structure","two-pointer","array","hashtable"]},{"title":"TwoSum problem and its similar Questions (part I)","url":"/two-sum-I.html","content":"\n## Introduction\n[TwoSum problem](https://leetcode.com/problems/two-sum/) is one of the most classic problems on Leetcode. You can find many blogs online explaining this problem. But in this blog (and the next blog), I will focus on not only solving this single problem, but also it's \"family members\" surrounding it. \n\nThe following graph is the \"family tree\" of TwoSum problem. They are connected because they have **Similar Questions** relation on Leetcode. In this blog, I'm going to explain the problems which have close relations to TwoSum problem.  The rest will be explained in the next blog.\n\n<img src=\"/images/two_sum_family_watermark.png\" style=\"float: right;\" width=\"400\" height=\"400\">\n\nLeetcode problems that will be discussed today:\n- [1. Two Sum (Easy)](https://leetcode.com/problems/two-sum/)\n- [15. 3Sum (Medium)](https://leetcode.com/problems/3sum/)\n- [18. 4Sum (Medium)](https://leetcode.com/problems/4sum/)\n- [167. Two Sum II - Input array is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)\n- [170. Two Sum III - Data structure design (Easy)](https://leetcode.com/problems/two-sum-iii-data-structure-design/)\n- [560. Subarray Sum Equals K (Medium)](https://leetcode.com/problems/subarray-sum-equals-k/)\n- [653. Two Sum IV - Input is a BST (Easy)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)\n- [1099. Two Sum Less Than K (Easy)](https://leetcode.com/problems/two-sum-less-than-k/)\n\n\n\n\n\n## TwoSum\n\nLet’s first look at the description of TwoSum problem.\n\n**Description:** \nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\nYou may assume that each input would have **exactly** one solution, and you may not use the **same** element twice.\n\n**Example:**\n```\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].\n```\n\n**Solution I - Brute force**\n\nFor the brute force solution, we need two levels of loop. In the first level, index `i` starts from 0 to the end of the array. In the second level, index `j` starts from `i+1` to the end of the array. As each input would have exactly one solution, whenever `nums[i] + nums[j] == target`, we can return `i` and `j`. The time complexity would be O(n^2). \n\nHere is the code:\n```python\n# brute force\ndef twoSum(self, nums, target):\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n```\n\n**Solution II - using hashmap**\n\nThe next step is to improve the brute force solution in terms of time complexity. Instead of having two loops, we can have one loop plus a hashmap. The hashmap stores each num's index and its partner number. Partner number is defined as `target - nums[i]`. If the current num is the partner number of its previous visited num, we return two indices. Time complexity is O(n). Space complexity is also O(n). \n\nHere is the code:\n```python\n# hashmap\ndef twoSum(self, nums, target):\n    hashmap = {}\n    for i in range(len(nums)):\n        if nums[i] not in hashmap:\n            hashmap[target - nums[i]] = i\n        else:\n            return [hashmap[nums[i]], i]\n```\n\n**Solution III - using two-pointers**\n\nTwo-pointer solution is also a good option here. It's a bit like binary search. We first sort the nums together with their indices as we need to return the indices not the actual numbers. Then we define two pointers `left` and `right` . `left` starts from the beginning and `right` starts from the end. In the while loop, we calculate the sum of `nums[left]` and `nums[right]` . If the sum is bigger than the target, we do `right-=1` . If the sum is smaller than the target, we do `left+=1` . If the sum is equal to the target, we return two indices.\n\nHere is the code:\n```python\n# two pointers\ndef twoSum(self, nums, target):\n\tnums = enumerate(nums)\n    nums = sorted(nums, key=lambda x:x[1])\n    l, r = 0, len(nums)-1\n    while l < r:\n        if nums[l][1]+nums[r][1] == target:\n            return sorted([nums[l][0], nums[r][0]])\n        elif nums[l][1]+nums[r][1] < target:\n            l += 1\n        else:\n            r -= 1\n```\n\n\n## ThreeSum & FourSum\n\nTwoSum problem solutions can be easily extended to solve [ThreeSum Problem](https://leetcode.com/problems/3sum/) and [FourSum Problem](https://leetcode.com/problems/4sum/). I'm only showing the solution for FourSum as it's already covered ThreeSum.\n\n**Description:**\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. The solution set must not contain duplicate triplets.\n\n**Example:**\n```\nGiven array nums = [-1, 0, 1, 2, -1, -4], and target = 0.\nA solution set is: [[-1, 0, 1],[-1, -1, 2]]\n```\nThe brute force solution is basically adding more loops and the time complexity is O(n^4). Here, I'm only showing the code of two-pointer solution. \n\nThis problem might have multiple solutions and the solution set must not contain duplicate triplets. So, we must skip numbers which are the same as their neighbours. The diagram below shows how it works inside `twoSum` function. The `target` is dynamic based on `nums[i]` in `threeSum` method.\n\n<img src=\"/images/1_1.png\" width=\"200\" height=\"200\">\n\n<img src=\"/images/1_2.png\" width=\"200\" height=\"200\">\n\n\nLet's checkout the code!\n\n```python\ndef twoSum(self, nums, target):\n    nums = sorted(nums)\n    l = 0\n    r = len(nums) - 1\n    res = []\n    while l < r:\n        tmp = nums[l] + nums[r]\n        if tmp == target:\n            res.append([nums[l], nums[r]])\n            l += 1\n            r -= 1\n            while l < r and nums[l] == nums[l - 1]: # skip duplicate numbers\n                l += 1\n            while l < r and nums[r] == nums[r + 1]: # skip duplicate numbers\n                r -= 1\n        elif tmp > target:\n            r -= 1\n        else:\n            l += 1\n    return res\n\n# O(n^2)\ndef threeSum(self, nums, target):\n    res = []\n    if len(nums) < 3:\n        return res\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        two_sum = self.twoSum(nums[i + 1 : len(nums)], target-nums[i])\n        for r in two_sum:\n            res.append([nums[i]] + r)\n    return res\n\n# O(n^3)\ndef fourSum(self, nums, target):\n    res = []\n    nums = sorted(nums)\n    for i in range(len(nums)-3):\n        if i > 0 and nums[i] == nums[i-1]: # skip duplicate numbers \n            continue\n        three_sum = self.threeSum(nums[i+1:len(nums)], target-nums[i])\n        for r in three_sum:\n            res.append([nums[i]] + r)\n    return res\n```\n\n## TwoSum II & TwoSum III\n\n[TwoSum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) assumes that the list is already sorted. We can just go for the two-pointer solution.\n```python\ndef twoSum(self, numbers, target):\n    nums = numbers\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        tmp = nums[l] + nums[r]\n        if tmp == target:\n            return [l+1, r+1]\n        elif tmp > target:\n            r -= 1\n        else:\n            l += 1\n```\n\n[TwoSum III](https://leetcode.com/problems/two-sum-iii-data-structure-design/) requires to design a class which includes `add` and `find` function. `add` - add the number to an internal data structure. `find` - find if there exists any pair of numbers which sum is equal to the value. \n\n```python\nclass TwoSum(object):\n\n    def __init__(self):\n        self.hashmap = {}        \n\n    def add(self, number):\n        if number in self.hashmap:\n            self.hashmap[number] += 1\n        else:\n            self.hashmap[number] = 1\n        \n    def find(self, value):\n        for key, val in self.hashmap.items():\n            if value - key in self.hashmap: # check if the \"partner\" is already in the hashmap\n                if value - key != key or self.hashmap[key] > 1: # avoid value=4, nums=[2]\n                    return True\n        return False\n```\n\n[Two Sum IV](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) puts numbers in a Binary Search Tree (BST). An important characteristic of BST is that if we do inorder traversal, we will get a sorted list. Two-pointer is a good option here.  \n\n```python\nclass Solution(object):\n    \n    def inorder(self, root, res):\n        if root:\n            self.inorder(root.left, res)\n            res.append(root.val)\n            self.inorder(root.right, res)      \n    \n    def findTarget(self, root, k):\n        res = []\n        self.inorder(root, res)\n        l = 0\n        r = len(res) - 1\n        while l < r:\n            sum = res[l] + res[r]\n            if sum == k:\n                return True\n            elif sum > k:\n                r -= 1\n            else:\n                l += 1\n        return False\n```\n\n## Subarray Sum Equals K & TwoSum Less Than K\n\n[Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) has an arry of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n\n**Example:**\n```\nInput:nums = [1,1,1], k = 2\nOutput: 2\n```\nBrute force solution considers every possible subarry of the given array. Whenenver the sum equals k, we can increment the result by 1. Time complexity would be O(n^3). \n\nAnother solution is to use cumulative sum. We first get a cumulative sum array `summ`. The sum between index `i` and `j` in `nums` is calculated by doing `summ[j] - summ[i]`. Time complexity would be O(n^2). \n\n<img src=\"/images/1_3.png\" width=\"120\" height=\"120\">\n\n```python\ndef subarraySum(self, nums, k):\n    sum = [None for _ in nums]\n    sum.insert(0,0)\n    res = 0\n    for i in range(1, len(nums) + 1):\n        sum[i] = sum[i - 1] + nums[i - 1]\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            if sum[j] - sum[i] == k:\n                res += 1\n    return res\n```\n\nAnother better solution posted on Leetcode is using hashmap. The idea is that when we accumulate the sum, we also check if it's partner is already in the hashmap (the same concept of TwoSum but in a different scenario). \n```python\ndef subarraySum(self, nums, k):\n    sum = 0\n    res = 0\n    hashmap = {}\n    hashmap[0] = 1 # include scenario like nums=[2] k=2\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum - k in hashmap:\n            res += hashmap[sum-k]\n        if sum in hashmap:\n            hashmap[sum] += 1\n        else:\n            hashmap[sum] = 1\n    return res\n```\n\n[Two Sum Less Than K](https://leetcode.com/problems/two-sum-less-than-k/) gives an array A of integers and integer K, return the maximum S such that there exists `i < j` with `A[i] + A[j] = S` and `S < K`. If no `i`, `j` exist satisfying this equation, return -1.\n\n**Example:**\n```\nInput: A = [34,23,1,24,75,33,54,8], K = 60\nOutput: 58\nExplanation: \nWe can use 34 and 24 to sum 58 which is less than 60.\n\nInput: A = [10,20,30], K = 15\nOutput: -1\nExplanation: \nIn this case it's not possible to get a pair sum less that 15.\n```\nIt's an easy variant of TwoSum. We need to find numbers that sum up to a value less than K. Here is the coding using two-pointer solution. \n\n```python\ndef twoSumLessThanK(self, A, K):\n    l = 0\n    r = len(A) - 1\n    A = sorted(A)\n    res = -float(\"inf\")    \n    while l < r:\n        sum = A[l] + A[r]\n        if sum == K or sum > K:\n            r -= 1\n        else:\n            res = max(res, sum)\n            l += 1\n    return res if res!=-float(\"inf\") else -1\n```\n\n**If you like this blog, please share it with your peers! Stay tuned on NotOverflow!**\n\n**If you have any comments or suggestions or if you need engineers for your project, please drop an email to hi.notoverflow@gmail.com, we can have a chat.**\n","tags":["leetcode","data structure","two-pointer","array","hashtable"]}]