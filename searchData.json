[{"title":"TwoSum problem and it's big family (part I)","url":"/2019/10/01/two-sum-I/","content":"\n## Introduction\n\n[TwoSum problem](https://leetcode.com/problems/two-sum/) is one of the most classic problems on Leetcode. You can easily find tons of articles online explaining this problem. But in this article (and the next article), I will focus on not only solving this single problem, but also it's \"family members\" surrounding it. \n\nThe following graph is the \"family tree\" of TwoSum problem. They are generated based on the **Similar Questions** relation on Leetcode. In this article, I'm going to explain the problems which have a direct relation with TwoSum problem.  The rest will be explained in the next article.\n\n<!-- ![TwoSum](/images/two_sum_family.png) -->\n<img src=\"/images/two_sum_family.png\" style=\"float: right;\" width=\"400\" height=\"400\">\n\nLeetcode problems mentioned in this article:\n- [1. Two Sum (Easy)](https://leetcode.com/problems/two-sum/)\n- [15. 3Sum (Medium)](https://leetcode.com/problems/3sum/)\n- [18. 4Sum (Medium)](https://leetcode.com/problems/4sum/)\n- [167. Two Sum II - Input array is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)\n- [170. Two Sum III - Data structure design (Easy)](https://leetcode.com/problems/two-sum-iii-data-structure-design/)\n- [560. Subarray Sum Equals K (Medium)](https://leetcode.com/problems/subarray-sum-equals-k/)\n- [653. Two Sum IV - Input is a BST (Easy)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)\n- [1099. Two Sum Less Than K (Easy)](https://leetcode.com/problems/two-sum-less-than-k/)\n\n\n\n\n\n## TwoSum\n\nLet’s first look at the description of TwoSum problem.\n\n**Description:** \nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\nYou may assume that each input would have **exactly** one solution, and you may not use the **same** element twice.\n\n**Example:**\n```\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].\n```\n\n**Solution I - Brute force**\n\nThe first solution in my mind is brute force. We need two levels of loop. In the first level, index `i` starts from 0 to the end of the list. In the second level, index `j` starts from `i+1` to the end of the list. As each input would have exactly one solution, whenever `nums[i] + nums[j] == target`, we can return `i` and `j`. The time complexity would be O(n^2). \n\nHere is the code:\n```python\n# brute force\ndef twoSum(self, nums, target):\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n```\n\n**Solution II - using hashmap**\n\nThe next step is to improve the brute force solution in terms of time complexity. Instead of having two loops, we can actually have one loop plus a hashmap. The key of the hashmap is the value of each number's partner (i.e. `target - nums[i]` ), the value is index `i`. If the current number is already in the key set, it means that its partner is in the list and has been visited. Then, we just return the index of it's partner (i.e. `hashmap[target - nums[i]]`) and the current index `i` . If not, then we add its partner and current index to the hashmap. Time complexity is O(n). Space complexity is also O(n). \n\nHere is the code:\n```python\n# hashmap\ndef twoSum(self, nums, target):\n    hashmap = {}\n    for i in range(len(nums)):\n        if nums[i] not in hashmap:\n            hashmap[target - nums[i]] = i\n        else:\n            return [hashmap[nums[i]], i]\n```\n\n**Solution III - using two-pointers**\n\nWe can also use two-pointers solution to reduce the time complexity. It's a bit like binary search. We first need to sort the nums together with its index as we need to return the indices not the actual numbers. Then we define two pointers `left` and `right` . `left` starts from the beginning and `right` starts from the end. In the while loop, we calculate the sum of `nums[left]` and `nums[right]` . If the sum is bigger than the target, we do `right-=1` . If the sum is smaller than the target, we do `left+=1` . If the sum is equal to the target, we return indices of `left` and `right`. \n\nHere is the code:\n```python\n# two pointers\ndef twoSum(self, nums, target):\n\tnums = enumerate(nums)\n    nums = sorted(nums, key=lambda x:x[1])\n    l, r = 0, len(nums)-1\n    while l < r:\n        if nums[l][1]+nums[r][1] == target:\n            return sorted([nums[l][0], nums[r][0]])\n        elif nums[l][1]+nums[r][1] < target:\n            l += 1\n        else:\n            r -= 1\n```\n\n\n## ThreeSum & FourSum\n\nTwoSum problem solutions can be easily extended to solve [ThreeSum Problem](https://leetcode.com/problems/3sum/) and [FourSum Problem](https://leetcode.com/problems/4sum/). I'm only showing the solution of FourSum as it's already covered ThreeSum.\n\n**Description:**\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. The solution set must not contain duplicate triplets.\n\n**Example:**\n```\nGiven array nums = [-1, 0, 1, 2, -1, -4], and target = 0.\nA solution set is: [[-1, 0, 1],[-1, -1, 2]]\n```\nThe brute force solution is basically adding more loops and the time complexity is O(n^4). Here, I'm showing the code of two-pointers solution. \n\nThis problem might have multiple solutions and the solution set must not contain duplicate triplets. Therefore, we should skip numbers which they are the same as their left or right neighbours. \n\n```python\ndef twoSum(self, nums, target):\n    nums = sorted(nums)\n    l = 0\n    r = len(nums) - 1\n    res = []\n    while l < r:\n        tmp = nums[l] + nums[r]\n        if tmp == target:\n            res.append([nums[l], nums[r]])\n            l += 1\n            r -= 1\n            while l < r and nums[l] == nums[l - 1]: # skip duplicate numbers\n                l += 1\n            while l < r and nums[r] == nums[r + 1]: # skip duplicate numbers\n                r -= 1\n        elif tmp > target:\n            r -= 1\n        else:\n            l += 1\n    return res\n\n# O(n^2)\ndef threeSum(self, nums, target):\n    res = []\n    if len(nums) < 3:\n        return res\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        two_sum = self.twoSum(nums[i + 1 : len(nums)], target-nums[i])\n        for r in two_sum:\n            res.append([nums[i]] + r)\n    return res\n\n# O(n^3)\ndef fourSum(self, nums, target):\n    res = []\n    nums = sorted(nums)\n    for i in range(len(nums)-3):\n        if i > 0 and nums[i] == nums[i-1]: # skip duplicate numbers \n            continue\n        three_sum = self.threeSum(nums[i+1:len(nums)], target-nums[i])\n        for r in three_sum:\n            res.append([nums[i]] + r)\n    return res\n```\n\n## TwoSum II & TwoSum III\n\n[TwoSum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) assumes that the list is already sorted. We can just go for the two-pointer solution.\n```python\ndef twoSum(self, numbers, target):\n    nums = numbers\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        tmp = nums[l] + nums[r]\n        if tmp == target:\n            return [l+1, r+1]\n        elif tmp > target:\n            r -= 1\n        else:\n            l += 1\n```\n\n[TwoSum III](https://leetcode.com/problems/two-sum-iii-data-structure-design/) requires to design a class which includes `add` and `find` function. `add` - add the number to an internal data structure. `find` - find if there exists any pair of numbers which sum is equal to the value. I'm using hashmap in this solution. \n\n```python\nclass TwoSum(object):\n\n    def __init__(self):\n        self.hashmap = {}        \n\n    def add(self, number):\n        if number in self.hashmap:\n            self.hashmap[number] += 1\n        else:\n            self.hashmap[number] = 1\n        \n    def find(self, value):\n        for key, val in self.hashmap.items():\n            if value - key in self.hashmap: # check if the \"partner\" is already in the hashmap\n                if value - key != key or self.hashmap[key] > 1: # avoid value=4, nums=[2]\n                    return True\n        return False\n```\n\n[Two Sum IV](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) puts numbers in a Binary Search Tree (BST). An important characteristic of BST is that if we do inorder traversal, we will get a sorted list. Then we can easily apply two-pointers solution. \n\n```python\nclass Solution(object):\n    \n    def inorder(self, root, res):\n        if root:\n            self.inorder(root.left, res)\n            res.append(root.val)\n            self.inorder(root.right, res)      \n    \n    def findTarget(self, root, k):\n        res = []\n        self.inorder(root, res)\n        l = 0\n        r = len(res) - 1\n        while l < r:\n            sum = res[l] + res[r]\n            if sum == k:\n                return True\n            elif sum > k:\n                r -= 1\n            else:\n                l += 1\n        return False\n```\n\n## Subarray Sum Equals K & TwoSum Less Than K\n\n[Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) has an arry of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n\n**Example:**\n```\nInput:nums = [1,1,1], k = 2\nOutput: 2\n```\nBrute force solution is to consider every possible subarry of the given array. Whenenver the sum equals k, we can increment the result by 1. Time complexity would be O(n^3). \n\nAnother solution is to use cummulative sum. We can calculate the sum between index `i` and `j` by doing `sum[j] - sum[i]` instead of iterating over the subarray. `sum[i]` is the cummulative sum from `0` to `i`. Time complexity would be O(n^2). \n```python\ndef subarraySum(self, nums, k):\n    sum = [None for _ in nums]\n    sum.insert(0,0)\n    res = 0\n    for i in range(1, len(nums) + 1):\n        sum[i] = sum[i - 1] + nums[i - 1]\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            if sum[j] - sum[i] == k:\n                res += 1\n    return res\n```\n\nAnother better solution posted on Leetcode is using hashmap. The idea is that when we accumulate the sum, we also check if it's partner is already in the hashmap (the same concept of TwoSum but in a different scenario). \n```python\ndef subarraySum(self, nums, k):\n    sum = 0\n    res = 0\n    hashmap = {}\n    hashmap[0] = 1 # include scenario like nums=[2] k=2\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum - k in hashmap:\n            res += hashmap[sum-k]\n        if sum in hashmap:\n            hashmap[sum] += 1\n        else:\n            hashmap[sum] = 1\n    return res\n```\n\n[Two Sum Less Than K](https://leetcode.com/problems/two-sum-less-than-k/) gives an array A of integers and integer K, return the maximum S such that there exists `i < j` with `A[i] + A[j] = S` and `S < K`. If no `i`, `j` exist satisfying this equation, return -1.\n\n**Example:**\n```\nInput: A = [34,23,1,24,75,33,54,8], K = 60\nOutput: 58\nExplanation: \nWe can use 34 and 24 to sum 58 which is less than 60.\n\nInput: A = [10,20,30], K = 15\nOutput: -1\nExplanation: \nIn this case it's not possible to get a pair sum less that 15.\n```\nIt's an easy variant of TwoSum. We need to find numbers that sum up to a value less than K. Here is the coding using two-pointers solution. \n\n```python\ndef twoSumLessThanK(self, A, K):\n    l = 0\n    r = len(A) - 1\n    A = sorted(A)\n    res = -float(\"inf\")\n    while l < r:\n        sum = A[l] + A[r]\n        if sum == K or sum > K:\n            r -= 1\n        else:\n            res = max(res, sum)\n            l += 1\n    return res if res!=-float(\"inf\") else -1\n```\n\n## Conclusion\n\nI like discovering relations among problems. Solving a single problem is only a temporary thing. \nIt is more important to understand the core of a \"simple\" problem, try to solve it in different ways and then extend the solutions to other related problems. In this way, you can solve problems on Leetcode more efficiently and remember the solutions more easily as well. \n\nIn the next article, I will explain the rest problems. Stay tuned! \n\n","tags":["leetcode","data structure","two-pointer","array","hashtable"]}]