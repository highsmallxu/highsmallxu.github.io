[{"title":"TwoSum problem and it's big family (part I)","url":"/2019/08/16/two-sum-I/","content":"\n## Introduction\n\n[TwoSum problem](https://leetcode.com/problems/two-sum/) is one of the most classic problems on Leetcode. You can easily find tons of articles online explaining this problem. But in this article (and the next article), I will focus on not only solving this single problem, but also it's \"family members\" surrounding it. \n\nThe following graph is the \"family tree\" of TwoSum problem. They are generated based on the **Similar Questions** relation on Leetcode. In this article, I'm going to explain the problems which have a direct relation with TwoSum problem.  The rest will be explained in the next article.\n\n<!-- ![TwoSum](/images/two_sum_family.png) -->\n<img src=\"/images/two_sum_family.png\" style=\"float: right;\" width=\"400\" height=\"400\">\n\nLeetcode problems mentioned in this article:\n- [1. Two Sum](https://leetcode.com/problems/two-sum/)\n- [15. 3Sum](https://leetcode.com/problems/3sum/)\n- [18. 4Sum](https://leetcode.com/problems/4sum/)\n- [167. Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)\n- [170. Two Sum III - Data structure design](https://leetcode.com/problems/two-sum-iii-data-structure-design/)\n- [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\n- [653. Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)\n- [1099. Two Sum Less Than K](https://leetcode.com/problems/two-sum-less-than-k/)\n\n\n\n\n\n## TwoSum\n\nLet’s first look at the description of TwoSum problem.\n\n**Description:** \nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\nYou may assume that each input would have **exactly** one solution, and you may not use the **same** element twice.\n\n**Example:**\n```\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].\n```\n\n**Solution I - Brute force**\n\nThe first solution in my mind is brute force. We need two levels of loop. In the first level, index `i` starts from 0 to the end of the list. In the second level, index `j` starts from `i+1` to the end of the list. As each input would have exactly one solution, whenever `nums[i] + nums[j] == target`, we can return `i` and `j`. The time complexity would be O(n^2). \n\nHere is the code:\n```python\n# brute force\ndef twoSum(self, nums, target):\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n```\n\n**Solution II - using hashmap**\n\nThe next step is to improve the brute force solution in terms of time complexity. Instead of having two loops, we can actually have one loop plus a hashmap. The key of the hashmap is the value of each number's partner (i.e. `target - nums[i]` ), the value is index `i`. If the current number is already in the key set, it means that its partner is in the list and has been visited. Then, we just return the index of it's partner (i.e. `hashmap[target - nums[i]]`) and the current index `i` . If not, then we add its partner and current index to the hashmap. Time complexity is O(n). Space complexity is also O(n). \n\nHere is the code:\n```python\n# hashmap\ndef twoSum(self, nums, target):\n    hashmap = {}\n    for i in range(len(nums)):\n        if nums[i] not in hashmap:\n            hashmap[target - nums[i]] = i\n        else:\n            return [hashmap[nums[i]], i]\n```\n\n**Solution III - using two-pointers**\n\nWe can also use two-pointers solution to reduce the time complexity. It's a bit like binary search. We first need to sort the nums together with its index as we need to return the indices not the actual numbers. Then we define two pointers `left` and `right` . `left` starts from the beginning and `right` starts from the end. In the while loop, we calculate the sum of `nums[left]` and `nums[right]` . If the sum is bigger than the target, we do `right-=1` . If the sum is smaller than the target, we do `left+=1` . If the sum is equal to the target, we return indices of `left` and `right`. \n\nHere is the code:\n```python\n# two pointers\ndef twoSum(self, nums, target):\n\tnums = enumerate(nums)\n    nums = sorted(nums, key=lambda x:x[1])\n    l, r = 0, len(nums)-1\n    while l < r:\n        if nums[l][1]+nums[r][1] == target:\n            return sorted([nums[l][0], nums[r][0]])\n        elif nums[l][1]+nums[r][1] < target:\n            l += 1\n        else:\n            r -= 1\n```\n\n\n## ThreeSum & FourSum","tags":["leetcode"]},{"title":"Two sum and it's big family II","url":"/2019/08/16/two-sum-II/","content":"## Introduction\n\nTwo Sum (Leetcode 1) problem is one of the most classic problems on Leetcode. You can easily find tons of articles online explaining this problem. But in this article (and the next article), I will explain not only this single problem, but it's *big family* surrounding it. \n\nThe following graph is the *family tree* of Two Sum problem. They are collected based on the *Similar Questions* relation on Leetcode. In this article, I will explain the problems which have a direct relation with TwoSum problem.  The rest will be explained in the next article.","tags":["leetcode"]},{"title":"Two sum and it's big family II","url":"/2019/08/16/two-sum-II copy/","content":"## Introduction\n\nTwo Sum (Leetcode 1) problem is one of the most classic problems on Leetcode. You can easily find tons of articles online explaining this problem. But in this article (and the next article), I will explain not only this single problem, but it's *big family* surrounding it. \n\nThe following graph is the *family tree* of Two Sum problem. They are collected based on the *Similar Questions* relation on Leetcode. In this article, I will explain the problems which have a direct relation with TwoSum problem.  The rest will be explained in the next article.","tags":["leetcode"]}]